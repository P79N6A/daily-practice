# 第3章 词法分析

## 3.1 词法分析的作用

### 3.1.2 词法单元、模式和词素

在讨论词法分析时，使用三个相关但有区别的术语：

* **词法单元：** 由一个词法单元名和一个可选的属性组成。
* **模式：** 描述一个词法单元的词素可能具有的形式。
* **词素：** 源程序中的一个字符序列。

### 3.3.3 正则表达式

归纳步骤：
1. (r) | (s) 是一个正则表达式，表示语言 L(r) | L(s)
2. (r)(s) 是一个正则表达式，表示语言 L(r)L(s)
3. (r)* 是一个正则表达式，表示语言 (L(r))*
4. (r) 是一个正则表达式，表示语言 L(r)

代数定律：
1. (r)* = (r)+|∊
2. (r)+ = r(r)* = (r) * r
3. (r)? = r|∊

### 3.3.4 正则定义

如果 Σ 是基本符号的集合，那么一个 正则定义(regular definition) 是具有定义的形式：
```
d₁ ⟶ r₁
d₂ ⟶ r₂
...
d𝑛 ⟶ r𝑛
```
其中：
* 每个 dᵢ 都是一个新符号，它们都不在 Σ 中，并且各不相同。
* 每个 rᵢ 是字母表 Σ ∪ {d₁,d₂, ..., dᵢ-₁} 上的正则表达式。

## 3.5 词法分析器生成工具Lex

### 3.5.2  Lex程序的结构
```
声明部分
%%
规则部分
%%
辅助函数
```

## 3.7 从正则表达式到自动机

#### 算法 3.20  NFA -> DFA 的子集构造(subset construction)算法

* **输入：** 一个 NFA N
* **输出：** 一个 DFA D
* **方法：** 为 D 构造一个转换表 Dtran。D 的每个状态是一个 NFA 状态集合，我们将构造 Dtran，使得 D 并行地模拟 N 在遇到一个给定输入时的可能执行的所有动作。请注意，s 表示 N 的单个状态，而 T 代表了 N 的一个状态集。

|    操作         |   描述                                                                        |
|:---------------|:------------------------------------------------------------------------------|
| ∊-closure(s)   | 能够从 NFA 的状态 s 开始只通过 ∊ 转换到达的 NFA 状态集合                             |
| ∊-closure(T)   | 能够从 T 中某个 NFA 的状态 s 开始只通过 ∊ 转换到达的 NFA 状态集合，即 Us∈T ∊-closure(s)|
| move(T, a)     | 能够从 T 中某个状态 s 出发通过标号为 a 的转换到达的 NFA 状态的集合                     |

子集构造算法：
```
一开始，∊-closure(s0) 是 Dstates 中的唯一状态，且它未加标记；
while (在 Dstates 中有一个未标记状态 T) {
    给 T 加上标记；
    for (每个输入符号 a) {
        U = ∊-closure(move(T, a))
        if (U 不在 Dstates 中)
            将 U 加入到 Dstates 中，且不加标记；
        Dtran[T, a] = U;
    }
}       
```

### 3.7.4 从正则表达式构造 NFA

#### 算法 3.23 正则 -> DFA 的 Thompson 算法
* **输入：** 字母表 Σ 上的一个正则表达式 r
* **输出：** 一个接受 L(r) 的 NFA N
* **方法：** 首先对 r 进行语法分析，分解出组成它的子表达式。构造一个 NFA 规则分为基本规则和归纳规则两组。基本规则处理不包含运算符的子表达式，而归纳规则 根据一个给定表达式的直接子表达式的 NFA 构造出这个表达式的 NFA。
* **基本规则：** 对于表达式 ∊ ，构造下面的 NFA：
```
start -> (i) --∊--> ((f))
```
这里，i 是一个新状态，也是这个 NFA 的开始状态；f 是另一个新状态，也是这个 NFA 的接受状态。

对于字母表 Σ 中的子表达式 a，构造下面的 NFA：
```
start -> (i) --a--> ((f))
```
同样，i 和 f 都是新状态，分别是这个 NFA 的开始状态和接受状态。

## 3.9 基于 DFA 的模式匹配的优化

### 3.9.1 NFA 的重要状态

如果一个 NFA 状态有一个标号非 ∊ 的离开转换，那我们称这个状态是重要状态（important state）。
在子集构造过程中，两个 NFA 状态集合可以被认为是一致的条件是：

1. 具有相同的的重要状态，且
2. 要么被包含接受状态，要么都不包含接受状态

### 3.9.6 最小化一个 DFA 的状态数

如果我们只需要改变状态名字就可以将一个自动机转换成另一个自动机，那么这两个自动机是同构的。
