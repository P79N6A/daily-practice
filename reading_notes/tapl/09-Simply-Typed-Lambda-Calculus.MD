# Chapter 9. Simply Typed Lambda-Calculus

## 9.1 Function Types

### 9.1.1 Definition: The set of simple types over the type Bool is generated by the following grammar:
```
T ::=                                          types:
        Bool                         type of booleans
        T➝T                         type of functions
```
The type constructor ➝ is right-associative—that is, the expression T1➝T2➝T3 stands for T1➝(T2➝T3).

## 9.2 The Typing Relation

Formally, a typing context (also called a type environment) 𝜞 is a sequence of variables and their types, and the "comma" operator extends 𝜞 by adding a new binding on the right. The empty context is sometimes written ∅, but usually we just omit it, writing ⊢ t: T for "The closed term t has type T under the empty set of assumptions."

```lambda
⟼ (typed)
------------------------------------------------------------
Syntax                      
t ::=                                            terms:
        x                                      variable
        ℷx:T.t                              abstraction
        t t                                 application

v ::=                                           values:
        ℷx:T.t                        abstraction value

T ::=                                            types:
        T➝T                           type of functions

𝜞 ::=                                         contexts:
        ∅                                 empty context
        𝜞, x:T                    term variable binding
------------------------------------------------------------
Evaluation                                 [t ⟼ t']

           t1 ⟼ t1'
        ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯                      (E-APP1)
        t1 t2 ⟼ t1' t2

           t2 ⟼ t2'
        ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯                      (E-APP2)
        v1 t2 ⟼ v1 t2'

    (ℷx:T11.t12)v2 ⟼ [x ⟼ v2]t12        (E-APP ABS)


Typing                                     [𝜞 ⟼ t:T]

                x:T ∈ 𝜞
                ¯¯¯¯¯¯¯¯                      (T-VAR)
                𝜞 ⊢ x:T

            𝜞,x:T1 ⊢ t2:T2
         ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯                (T-ABS)
         𝜞 ⊢ ℷx:T1.t2: T1⟼T2       

        𝜞 ⊢ t1:T11⟼T12  𝜞 ⊢ t2:T11
        ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯           (T-APP)
             𝜞 ⊢ t1 t2: T12
------------------------------------------------------------
```

## 9.3 Properties of Typing

### 9.3.1 Lemma [Inversion of the typing relation]:

1. If 𝜞 ⊢ x: R, then x:R ∈ 𝜞 .
2. If 𝜞 ⊢ ℷx:T1.t2: R, then R = T1⟼R2 for some R2 with 𝜞 , x:T1 ⊢ t2: R2.
3. If 𝜞 ⊢ t1 t2: R, then there is some type T11 such that 𝜞 ⊢ t1: T11⟼R and 𝜞 ⊢ t2: T11.
4. If 𝜞 ⊢ true: R, then R = Bool.
5. If 𝜞 ⊢ false: R, then R = Bool.
6. If 𝜞 ⊢ if t1 then t2 else t3: R, then 𝜞 ⊢ t1: Bool and 𝜞 ⊢ t2, t3: R .

### 9.3.4 Lemma [Canonical Forms]:

1. If v is a value of type Bool, then v is either true or false.
2. If v is a value of type T1⟼T2, then v = ℷx:T1.t2.

### 9.3.5 Theorem [Progress]: Suppose t is a closed, well-typed term (that is, ⊢ t: T for some T). Then either t is a value or else there is some t0 with t⟼t0.

## 9.4 The Curry-Howard Correspondence

The "⟼" type constructor comes with typing rules of two kinds:
1. an introduction rule (T-Abs) describing how elements of the type can be created, and
2. an elimination rule (T-App) describing how elements of the type can be used.

Briefly, the idea is that, in constructive logics, a proof of a proposition P consists of concrete
evidence for P. What Curry and Howard noticed was that such evidence has a strongly computational feel. For example, a proof of a proposition P ⊂ Q can be viewed as a mechanical procedure that, given a proof of P, constructs a proof of Q—or, if you like, a proof of Q abstracted on a proof of P. Similarly, a proof of P ^ Q consists of a proof of P together with a proof of Q. This observation gives rise to the following correspondence:

```
Logic                           Programming languages
-----------------------------------------------------
propositions                    types
proposition P ⊃ Q               type P⟼Q
proposition P ^ Q               type P × Q
proof of proposition P          term t of type P
proposition P is provable       type P is inhabited
```

## 9.5 Erasure and Typability

### 9.5.1 Definition: The erasure of a simply typed term t is defined as follows:
```lambda
erase(x)           = x
erase(ℷx:T1. t2)   = ℷx. erase(t2)
erase(t1 t2)       = erase(t1) erase(t2)
```

### 9.5.2 Theorem:
1. If t ⟼ t' under the typed evaluation relation, then erase(t) ⟼ erase(t').
2. If erase(t) ⟼ m' under the typed evaluation relation, then there is a simply
typed term t' such that t ⟼ t' and erase(t') = m'.

### 9.5.3 Definition: A term m in the untyped lambda-calculus is said to be typable in ℷ→ if there are some simply typed term t, type T, and context 𝜞 such that erase(t) = m and 𝜞 ⊢ t: T.

### 9.6 Curry-Style vs. Church-Style
Historically, implicitly typed presentations of lambda-calculi are often given in the Curry style, while Church-style presentations are common only for explicitly typed systems. This has led to some confusion of terminology: "Church-style" is sometimes used when describing an explicitly typed syntax and "Curry-style" for implicitly typed.