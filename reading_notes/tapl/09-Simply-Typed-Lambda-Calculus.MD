# Chapter 9. Simply Typed Lambda-Calculus

## 9.1 Function Types

### 9.1.1 Definition: The set of simple types over the type Bool is generated by the following grammar:
```
T ::=                                          types:
        Bool                         type of booleans
        TâT                         type of functions
```
The type constructor â is right-associativeâ€”that is, the expression T1âT2âT3 stands for T1â(T2âT3).

## 9.2 The Typing Relation

Formally, a typing context (also called a type environment) ğœ is a sequence of variables and their types, and the "comma" operator extends ğœ by adding a new binding on the right. The empty context is sometimes written âˆ…, but usually we just omit it, writing âŠ¢ t: T for "The closed term t has type T under the empty set of assumptions."

```lambda
âŸ¼ (typed)
------------------------------------------------------------
Syntax                      
t ::=                                            terms:
        x                                      variable
        â„·x:T.t                              abstraction
        t t                                 application

v ::=                                           values:
        â„·x:T.t                        abstraction value

T ::=                                            types:
        TâT                           type of functions

ğœ ::=                                         contexts:
        âˆ…                                 empty context
        ğœ, x:T                    term variable binding
------------------------------------------------------------
Evaluation                                 [t âŸ¼ t']

           t1 âŸ¼ t1'
        Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯                      (E-APP1)
        t1 t2 âŸ¼ t1' t2

           t2 âŸ¼ t2'
        Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯                      (E-APP2)
        v1 t2 âŸ¼ v1 t2'

    (â„·x:T11.t12)v2 âŸ¼ [x âŸ¼ v2]t12        (E-APP ABS)


Typing                                     [ğœ âŸ¼ t:T]

                x:T âˆˆ ğœ
                Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯                      (T-VAR)
                ğœ âŠ¢ x:T

            ğœ,x:T1 âŠ¢ t2:T2
         Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯                (T-ABS)
         ğœ âŠ¢ â„·x:T1.t2: T1âŸ¼T2       

        ğœ âŠ¢ t1:T11âŸ¼T12  ğœ âŠ¢ t2:T11
        Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯           (T-APP)
             ğœ âŠ¢ t1 t2: T12
------------------------------------------------------------
```

## 9.3 Properties of Typing

### 9.3.1 Lemma [Inversion of the typing relation]:

1. If ğœ âŠ¢ x: R, then x:R âˆˆ ğœ .
2. If ğœ âŠ¢ â„·x:T1.t2: R, then R = T1âŸ¼R2 for some R2 with ğœ , x:T1 âŠ¢ t2: R2.
3. If ğœ âŠ¢ t1 t2: R, then there is some type T11 such that ğœ âŠ¢ t1: T11âŸ¼R and ğœ âŠ¢ t2: T11.
4. If ğœ âŠ¢ true: R, then R = Bool.
5. If ğœ âŠ¢ false: R, then R = Bool.
6. If ğœ âŠ¢ if t1 then t2 else t3: R, then ğœ âŠ¢ t1: Bool and ğœ âŠ¢ t2, t3: R .

### 9.3.4 Lemma [Canonical Forms]:

1. If v is a value of type Bool, then v is either true or false.
2. If v is a value of type T1âŸ¼T2, then v = â„·x:T1.t2.

### 9.3.5 Theorem [Progress]: Suppose t is a closed, well-typed term (that is, âŠ¢ t: T for some T). Then either t is a value or else there is some t0 with tâŸ¼t0.

## 9.4 The Curry-Howard Correspondence

The "âŸ¼" type constructor comes with typing rules of two kinds:
1. an introduction rule (T-Abs) describing how elements of the type can be created, and
2. an elimination rule (T-App) describing how elements of the type can be used.

Briefly, the idea is that, in constructive logics, a proof of a proposition P consists of concrete
evidence for P. What Curry and Howard noticed was that such evidence has a strongly computational feel. For example, a proof of a proposition P âŠ‚ Q can be viewed as a mechanical procedure that, given a proof of P, constructs a proof of Qâ€”or, if you like, a proof of Q abstracted on a proof of P. Similarly, a proof of P ^ Q consists of a proof of P together with a proof of Q. This observation gives rise to the following correspondence:

```
Logic                           Programming languages
-----------------------------------------------------
propositions                    types
proposition P âŠƒ Q               type PâŸ¼Q
proposition P ^ Q               type P Ã— Q
proof of proposition P          term t of type P
proposition P is provable       type P is inhabited
```

## 9.5 Erasure and Typability

### 9.5.1 Definition: The erasure of a simply typed term t is defined as follows:
```lambda
erase(x)           = x
erase(â„·x:T1. t2)   = â„·x. erase(t2)
erase(t1 t2)       = erase(t1) erase(t2)
```

### 9.5.2 Theorem:
1. If t âŸ¼ t' under the typed evaluation relation, then erase(t) âŸ¼ erase(t').
2. If erase(t) âŸ¼ m' under the typed evaluation relation, then there is a simply
typed term t' such that t âŸ¼ t' and erase(t') = m'.

### 9.5.3 Definition: A term m in the untyped lambda-calculus is said to be typable in â„·â†’ if there are some simply typed term t, type T, and context ğœ such that erase(t) = m and ğœ âŠ¢ t: T.

### 9.6 Curry-Style vs. Church-Style
Historically, implicitly typed presentations of lambda-calculi are often given in the Curry style, while Church-style presentations are common only for explicitly typed systems. This has led to some confusion of terminology: "Church-style" is sometimes used when describing an explicitly typed syntax and "Curry-style" for implicitly typed.